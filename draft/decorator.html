<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>风雪围城</title>

  
  <meta name="author" content="YueGS">
  

  
  <meta name="description" content="装饰器是一个函数或者类，其在不改变原函数的情况下，通过 “包装”另一个函数或者类，以达到功能增强或者行为改变的效果。常用语日志记录、权限验证、数据校验、性能监控等。
本质上是一个高阶函数（接收其他函数作为输入，或者返回一个函数的函数），它接受一个函数作为参数，并返回一个新的函数。
123456789">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="风雪围城"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="风雪围城" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">风雪围城</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span></span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/draft/decorator.html" rel="bookmark">
        <time class="entry-date published" datetime="2025-01-15T01:54:22.423Z">
          2025-01-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>装饰器是一个函数或者类，其在不改变原函数的情况下，通过 “包装”另一个函数或者类，以达到功能增强或者行为改变的效果。常用语日志记录、权限验证、数据校验、性能监控等。</p>
<p><strong>本质上是一个高阶函数（接收其他函数作为输入，或者返回一个函数的函数）</strong>，它接受一个函数作为参数，并返回一个新的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个简单的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用函数前执行一些操作&quot;</span>)</span><br><span class="line">        func()  <span class="comment"># 调用原函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用函数后执行一些操作&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用装饰器</span></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的函数</span></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello = my_decorator(say_hello)  <span class="comment"># 手动应用装饰器</span></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>

<p>当装饰器是一个类的时候，它的行为和函数装饰器类似，但它通常使用类的构造方法和__call__方法来实现装饰器功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDecorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用函数前执行一些操作&quot;</span>)</span><br><span class="line">        result = self.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用函数后执行一些操作&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类装饰器</span></span><br><span class="line"><span class="meta">@MyDecorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的函数</span></span><br><span class="line">say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用类这种方式，显然可以更方便地封装更复杂的处理逻辑。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包也是一个函数。该函数内部定义了一个嵌套函数，而嵌套函数又引用了这个外部函数的变量，如此一来，当返回这个嵌套函数时，这个嵌套函数就包含了外部函数的变量，这个嵌套函数就称为闭包函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>():</span><br><span class="line">    series = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="comment"># series 为外部函数 outer_function 的局部变量，也是 inner_function 中的自由变量</span></span><br><span class="line">        series.append(y) </span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total/<span class="built_in">len</span>(series)</span><br><span class="line">    <span class="keyword">return</span> inner_function</span><br><span class="line"></span><br><span class="line">func = outer_function()</span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_varnames)</span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_freevars)</span><br><span class="line"><span class="built_in">print</span>(func.__closure__)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自由变量通常来自于外部函数的作用域或全局作用域。当一个函数访问这些自由变量时，Python 会根据 LEGB（Local, Enclosing, Global, Built-in） 规则进行查找。首先查找封闭作用域（如果有嵌套函数），然后查找全局作用域，最后查找内建作用域（Python 解释器自动提供，包含了 Python 标准库中的一些常用的内建函数和常量）。</p>
</blockquote>
<p>装饰器通常是闭包的一种应用。</p>
<p>在 JS 中，也有闭包的概念，它和 Python 的定义和作用是类似的，都是一个函数内部定义了另一个函数，并且这个内部函数引用了外部函数的变量，都允许函数记住和访问它在被定义是的作用域，即使这个作用域已经离开。<br>但是，它们也有一些不同点：</p>
<ul>
<li>Python 中按照 LEGB 规则进行变量查找，而 JS 使用词法作用域（lexical scoping），通过作用域链解析变量。</li>
<li>Python 的闭包中，无法直接修改外部函数的变量（如需修改，需要使用 <code>nonlocal</code> 或 <code>global</code> 关键字），而 JS 中可以。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    
    &copy; 2025 YueGS
    
  </p>
</footer>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116967169-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-116967169-1');
</script>

    
  </div>
</div>
</body>
</html>